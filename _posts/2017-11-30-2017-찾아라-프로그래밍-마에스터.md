---
title: 2017 찾아라 프로그래밍 마에스터 (중소/중견기업 채용 연계 프로그래밍 대회)
description: 
categories: 
tags: algorithm
---

![programmers](../assets/images/programmers.png)

[]https://programmers.co.kr/competitions/52/2017-%EC%B0%BE%EC%95%84%EB%9D%BC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%A7%88%EC%97%90%EC%8A%A4%ED%84%B0)<br/>
문제와 해설은 해설링크로 들어가면 나와있습니다. 문제1, 문제2에 대한 풀이를 하겠습니다.

# 문제1 - 폰켓몬

## 문제 설명

당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다. 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다.<br/>
홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다. 이때, 4마리의 폰켓몬 중 2마리를 고르는 방법은 다음과 같이 6가지가 있습니다.

1. 첫 번째(3번), 두 번째(1번) 폰켓몬을 선택
1. 첫 번째(3번), 세 번째(2번) 폰켓몬을 선택
1. 첫 번째(3번), 네 번째(3번) 폰켓몬을 선택
1. 두 번째(1번), 세 번째(2번) 폰켓몬을 선택
1. 두 번째(1번), 네 번째(3번) 폰켓몬을 선택
1. 세 번째(2번), 네 번째(3번) 폰켓몬을 선택

이때, 첫 번째(3번) 폰켓몬과 네 번째(3번) 폰켓몬을 선택하는 방법은 한 종류(3번 폰켓몬 두 마리)의 폰켓몬만 가질 수 있지만, 다른 방법들은 모두 두 종류의 폰켓몬을 가질 수 있습니다. 따라서 위 예시에서 가질 수 있는 폰켓몬 종류 수의 최댓값은 2가 됩니다.<br/>
당신은 최대한 다양한 종류의 폰켓몬을 가지길 원하기 때문에, 최대한 많은 종류의 폰켓몬을 포함해서 N/2마리를 선택하려 합니다. N마리 폰켓몬의 종류 번호가 담긴 배열 nums가 매개변수로 주어질 때, N/2마리의 폰켓몬을 선택하는 방법 중, 가장 많은 종류의 폰켓몬을 선택하는 방법을 찾아, 그때의 폰켓몬 종류 번호의 개수를 return 하도록 solution 함수를 완성해주세요.

## 제한사항

* nums는 폰켓몬의 종류 번호가 담긴 1차원 배열입니다.
* nums의 길이(N)는 1 이상 10,000 이하의 자연수이며, 항상 짝수로 주어- 집니다.
* 폰켓몬의 종류 번호는 1 이상 200,000 이하의 자연수로 나타냅니다.
* 가장 많은 종류의 폰켓몬을 선택하는 방법이 여러 가지인 경우에도, 선택할 수 있는 폰켓몬 종류 개수의 최댓값 하나만 return 하면 됩니다.

## 입출력 예

| nums | result |
| [3,1,2,3] | 2 |
| [3,3,3,2,2,4] | 3 |
| [3,3,3,2,2,2] | 2 |

## 입출력 예 설명

**입출력 예 #1**
: 문제의 예시와 같습니다.<br/>
<br/>
**입출력 예 #2**
: 6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다.<br/>
가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리, 2번 폰켓몬 한 마리, 4번 폰켓몬 한 마리를 고르면 되며, 따라서 3을 return 합니다.

**입출력 예 #3**
: 6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다.<br/>
가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리와 2번 폰켓몬 두 마리를 고르거나, 혹은 3번 폰켓몬 두 마리와 3번 폰켓몬 한 마리를 고르면 됩니다. 따라서 최대 고를 수 있는 폰켓몬 종류의 수는 2입니다.

## 해설

<script src="https://gist.github.com/groovypark/208f570a9bfd21830dd28b3755135270.js"></script>

처음에는 입력값의 숫자들을 하나씩 확인해야 한다고 생각했다. 하지만 결국 폰켓몬 종류와 고를 수 있는 폰켓몬은 정해져 있으므로, 그 두가지 숫자만 비교하면 된다. 따라서 고를 수 있는 폰켓몬(n/2마리)을 half 변수에 저장하였다.<br/>
첫번째 케이스는 ArrayList를 만들어서 포함하지 않는 폰켓몬의 종류번호를 추가했다. 그렇게 폰켓몬의 중복되지 않는 종류번호들의 배열이 만들어지면, half와 배열의 크기를 비교하여 더 작은 것을 리턴한다.<br/>
두번째 케이스는 제한사항에서 폰켓몬의 종류번호는 1 이상 200,000이하의 자연수 이므로 boolean[200001]을 만들고 해당하는 종류번호에 체크하는 방법을 사용하였다. 이미 체크가 되어있다면 다음으로 넘어가고, 체크가 안되어있으면 체크한 뒤 폰켓몬의 종류인 count변수에 1을 더해준다. 만약 고를 수 있는 폰켓몬이 폰켓몬 종류보다 작다면 고를 수 있는 폰켓몬인 half변수를 리턴하고, 반대의 경우에는 폰켓몬 종류인 count변수를 리턴한다.

# 문제2 - 게임 맵 최단거리

## 문제 설명

ROR 게임은 두 팀으로 나누어서 진행하며, 상대 팀 진영을 먼저 파괴하면 이기는 게임입니다. 따라서, 각 팀은 상대 팀 진영에 최대한 빨리 도착하는 것이 유리합니다.<br/>
<br/>
지금부터 당신은 한 팀의 팀원이 되어 게임을 진행하려고 합니다. 다음은 5 x 5 크기의 맵에, 당신의 캐릭터가 (행: 1, 열: 1) 위치에 있고, 상대 팀 진영은 (행: 5, 열: 5) 위치에 있는 경우의 예시입니다.<br/>

![](https://res.cloudinary.com/jistring93/image/upload/v1482130533/%EC%B5%9C%EB%8B%A8%EA%B1%B0%EB%A6%AC1_sxuruo.png)

위 그림에서 검은색 부분은 벽으로 막혀있어 갈 수 없는 길이며, 흰색 부분은 갈 수 있는 길입니다. 캐릭터가 움직일 때는 동, 서, 남, 북 방향으로 한 칸씩 이동하며, 게임 맵을 벗어난 길은 갈 수 없습니다.<br/>
아래 예시는 캐릭터가 상대 팀 진영으로 가는 두 가지 방법을 나타내고 있습니다.<br/>
<br/>
첫 번째 방법은 11개의 칸을 지나서 상대 팀 진영에 도착했습니다.
![](https://res.cloudinary.com/jistring93/image/upload/v1482130625/%EC%B5%9C%EB%8B%A8%EA%B1%B0%EB%A6%AC2_hnjd3b.png)
<br/>
두 번째 방법은 15개의 칸을 지나서 상대팀 진영에 도착했습니다.
![](https://res.cloudinary.com/jistring93/image/upload/v1482130687/%EC%B5%9C%EB%8B%A8%EA%B1%B0%EB%A6%AC3_ntxygd.png)
<br/>
위 예시에서는 첫 번째 방법보다 더 빠르게 상대팀 진영에 도착하는 방법은 없으므로, 이 방법이 상대 팀 진영으로 가는 가장 빠른 방법입니다.<br/>
<br/><br/>
만약, 상대 팀이 자신의 팀 진영 주위에 벽을 세워두었다면 상대 팀 진영에 도착하지 못할 수도 있습니다. 예를 들어, 다음과 같은 경우에 당신의 캐릭터는 상대 팀 진영에 도착할 수 없습니다.<br/>
<br/>
![](https://res.cloudinary.com/jistring93/image/upload/v1482130852/%EC%B5%9C%EB%8B%A8%EA%B1%B0%EB%A6%AC4_of9xfg.png)
<br/>
게임 맵의 상태 maps가 매개변수로 주어질 때, 캐릭터가 상대 팀 진영에 도착하기 위해서 지나가야 하는 칸의 개수의 최솟값을 return 하도록 solution 함수를 완성해주세요. 단, 상대 팀 진영에 도착할 수 없을 때는 -1을 return 해주세요.

## 제한사항

* maps는 n x m 크기의 게임 맵의 상태가 들어있는 2차원 배열로, n과 m은 각각 1 이상 100 이하의 자연수입니다.
* n과 m은 서로 같을 수도, 다를 수도 있지만, n과 m이 모두 1인 경우는 입력으로 주어지지 않습니다.
* maps는 0과 1로만 이루어져 있으며, 0은 벽이 있는 자리, 1은 벽이 없는 자리를 나타냅니다.
* 처음에 캐릭터는 게임 맵의 좌측 상단인 (1, 1) 위치에 있으며, 상대방 진영은 게임 맵의 우측 하단인 (n, m) 위치에 있습니다.

## 입출력 예

| maps | answer |
| [[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,1],[0,0,0,0,1]] | 11 |
| [[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,0],[0,0,0,0,1]] | -1 |

## 입출력 예 설명

**입출력 예 #1**
: 주어진 데이터는 다음과 같습니다.

![](https://res.cloudinary.com/jistring93/image/upload/v1482132321/%EC%B5%9C%EB%8B%A8%EA%B1%B0%EB%A6%AC6_lgjvrb.png)
<br/>
캐릭터가 적 팀의 진영까지 이동하는 가장 빠른 길은 다음 그림과 같습니다.
<br/>
![](https://res.cloudinary.com/jistring93/image/upload/v1482132321/%EC%B5%9C%EB%8B%A8%EA%B1%B0%EB%A6%AC6_lgjvrb.png)
<br/>
따라서 총 11칸을 캐릭터가 지나갔으므로 11을 return 하면 됩니다.<br/>
<br/>
**입출력 예 #2**
: 문제의 예시와 같으며, 상대 팀 진영에 도달할 방법이 없습니다. 따라서 -1을 return 합니다.

## 해설

<script src="https://gist.github.com/groovypark/cac4a26a5bd583259cccdb60c4179778.js"></script>

첫번째 케이스는 객체지향적으로 Direction과 Status class를 만들어 더 직관적으로 볼 수 있게 만들었다. x,y좌표로 4가지 방향을 설정하였고 nm으로 map의 크기를 설정하였다. 현재위치는 큐에서 꺼낸다. 만약 현재 위치가 0이거나(길이 아닌 경우) 방문했으면 다음길로 넘어가고, 마지막 좌표인 경우에는 count를 리턴해준다. count는 현재좌표의 지나간 칸의 개수이다. Directions는  상,하,좌,우 4가지 좌표를 가지고 있다. 새로운 좌표를 가게 되면, 4가지 방향을 모두 따지고 새로운 좌표가 맵의 좌표에 포함이 되면 큐에 새로운 좌표를 넣어준다. 그렇게 새로운 좌표들이 들어갈때마다 count를 1씩 더해주면서 최종적으로 지나간 칸의 개수의 최솟값을 리턴하게 된다.<br/>
두번째 케이스는 x,y좌표를 배열로 설정한 뒤 똑같이 큐를 이용하였다.</br>
두번째 케이스로 먼저 풀고 객체지향적으로 첫번째 케이스로 바꿔보았다.


